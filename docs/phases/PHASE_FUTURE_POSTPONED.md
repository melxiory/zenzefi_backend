# Phase Future: Postponed Features

**–°—Ç–∞—Ç—É—Å:** üìã –û–¢–õ–û–ñ–ï–ù–û
**–í–µ—Ä—Å–∏—è:** v0.7.0+ (–±—É–¥—É—â–∏–µ —Ä–µ–ª–∏–∑—ã)
**–ü—Ä–∏—á–∏–Ω–∞:** –§–∏—á–∏ –æ—Ç–ª–æ–∂–µ–Ω—ã –¥–ª—è —Ñ–æ–∫—É—Å–∞ –Ω–∞ core monetization –∏ UX improvements

---

## üìñ –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

- [–í–≤–µ–¥–µ–Ω–∏–µ](#–≤–≤–µ–¥–µ–Ω–∏–µ)
- [Token Auto-Renewal (–ê–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ)](#token-auto-renewal-–∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ)
- [Token Gifting (–ü–æ–¥–∞—Ä–æ—á–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã)](#token-gifting-–ø–æ–¥–∞—Ä–æ—á–Ω—ã–µ-—Ç–æ–∫–µ–Ω—ã)
- [Sprint 3: Developer Ecosystem (v0.9.0-beta)](#sprint-3-developer-ecosystem-v090-beta)
  - [Webhook Notifications (Webhook –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)](#webhook-notifications-webhook-–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)
  - [Multi-Currency Support (–ú—É–ª—å—Ç–∏–≤–∞–ª—é—Ç–Ω–æ—Å—Ç—å)](#multi-currency-support-–º—É–ª—å—Ç–∏–≤–∞–ª—é—Ç–Ω–æ—Å—Ç—å)
  - [API Rate Limiting Tiers (–¢–∞—Ä–∏—Ñ–Ω—ã–µ –ø–ª–∞–Ω—ã)](#api-rate-limiting-tiers-—Ç–∞—Ä–∏—Ñ–Ω—ã–µ-–ø–ª–∞–Ω—ã)

---

## –í–≤–µ–¥–µ–Ω–∏–µ

–≠—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–µ—Ç–∞–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ **–æ—Ç–ª–æ–∂–µ–Ω–Ω—ã—Ö —Ñ–∏—á** –¥–ª—è Zenzefi Backend, –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω—ã, –Ω–æ –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–ª–æ–∂–µ–Ω—ã –¥–ª—è —Ñ–æ–∫—É—Å–∞ –Ω–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö:

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ —Ñ–∏—á–∏ (Active Development):**
- ‚úÖ Token Bundles (–ü–∞–∫–µ—Ç–Ω—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)
- ‚úÖ Referral System (–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞)
- ‚úÖ Usage Analytics (–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è)
- ‚úÖ Email Notifications (Email —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è)
- ‚úÖ Prometheus Dashboards (Grafana –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥)

**–û—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ —Ñ–∏—á–∏ (Postponed):**
- ‚è∏Ô∏è Token Auto-Renewal (–ê–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ)
- ‚è∏Ô∏è Token Gifting (–ü–æ–¥–∞—Ä–æ—á–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã)
- ‚è∏Ô∏è Webhook Notifications (Webhook –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)
- ‚è∏Ô∏è Multi-Currency Support (–ú—É–ª—å—Ç–∏–≤–∞–ª—é—Ç–Ω–æ—Å—Ç—å)
- ‚è∏Ô∏è API Rate Limiting Tiers (–¢–∞—Ä–∏—Ñ–Ω—ã–µ –ø–ª–∞–Ω—ã)

**–ü—Ä–∏—á–∏–Ω—ã –æ—Ç–ª–æ–∂–µ–Ω–∏—è:**
1. **Token Auto-Renewal** - –¢—Ä–µ–±—É–µ—Ç —Å–ª–æ–∂–Ω–æ–π —Ñ–æ–Ω–æ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏ email –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏; –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ—Å–ª–µ —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏–∏ Email Notifications
2. **Token Gifting** - –°–æ—Ü–∏–∞–ª—å–Ω–∞—è —Ñ–∏—á–∞, –ø–æ–ª–µ–∑–Ω–∞—è –ø–æ—Å–ª–µ —Ä–æ—Å—Ç–∞ user base; —Ç—Ä–µ–±—É–µ—Ç email –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
3. **Sprint 3 (Developer Ecosystem)** - –§–∏—á–∏ –¥–ª—è enterprise/B2B —Å–µ–≥–º–µ–Ω—Ç–∞; –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –Ω–∞ B2C monetization

**–ö–æ–≥–¥–∞ –±—É–¥—É—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã:**
- Token Auto-Renewal: –ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ Email Notifications (Sprint 2)
- Token Gifting: –ü–æ—Å–ª–µ —Ä–æ—Å—Ç–∞ user base –¥–æ 500+ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- Sprint 3 —Ñ–∏—á–∏: –ü–æ—Å–ª–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è v1.0.0 –∏ —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã

---

## Token Auto-Renewal (–ê–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ)

### –ë–∏–∑–Ω–µ—Å-–æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ

**–ü—Ä–æ–±–ª–µ–º–∞:** –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∑–∞–±—ã–≤–∞—é—Ç –ø—Ä–æ–¥–ª–µ–≤–∞—Ç—å —Ç–æ–∫–µ–Ω—ã ‚Üí churn. –û–¥–Ω–æ—Ä–∞–∑–æ–≤—ã–µ –ø–æ–∫—É–ø–∫–∏ –≤–º–µ—Å—Ç–æ recurring revenue.

**–†–µ—à–µ–Ω–∏–µ:** Subscription-like model —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø—Ä–æ–¥–ª–µ–Ω–∏–µ–º —Ç–æ–∫–µ–Ω–æ–≤.

**–ú–µ—Ö–∞–Ω–∏–∫–∞:**
1. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–∫–ª—é—á–∞–µ—Ç auto-renewal –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö (opt-in)
2. –í—ã–±–∏—Ä–∞–µ—Ç duration –¥–ª—è –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏—è (1h, 12h, 24h, 7d, 30d)
3. –ö–æ–≥–¥–∞ –ª—é–±–æ–π —Ç–æ–∫–µ–Ω < 24 —á–∞—Å–∞ –¥–æ –∏—Å—Ç–µ—á–µ–Ω–∏—è ‚Üí –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø–æ–∫—É–ø–∫–∞ –Ω–æ–≤–æ–≥–æ
4. –ï—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–ª–∞–Ω—Å–∞ ‚Üí email notification, auto-renewal pause

**–¶–µ–Ω–Ω–æ—Å—Ç—å:**
- **Recurring revenue**: Subscription –º–æ–¥–µ–ª—å –≤–º–µ—Å—Ç–æ one-time purchases
- **Retention**: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –∑–∞–±—ã–≤–∞—é—Ç –ø—Ä–æ–¥–ª—è—Ç—å ‚Üí lower churn
- **Convenience**: Set-and-forget experience ‚Üí higher satisfaction
- **Predictable revenue**: –õ–µ–≥—á–µ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å cash flow

**Expected Impact:**
- Recurring revenue: +25-40% —á–µ—Ä–µ–∑ auto-renewal users
- Retention: +20-30% (users don't forget to renew)
- LTV: +50-100% (subscription users stay longer)

---

### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏

**Database Model Changes:**

```python
# app/models/user.py - –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—è
class User(Base):
    # ... existing fields

    # Auto-renewal settings (NEW)
    auto_renew_enabled = Column(
        Boolean,
        default=False,
        nullable=False,
        comment="Enable auto-renewal of tokens"
    )

    auto_renew_duration_hours = Column(
        Integer,
        nullable=True,
        comment="Duration for auto-renewed tokens (1, 12, 24, 168, 720)"
    )

    auto_renew_scope = Column(
        String(50),
        default="full",
        nullable=True,
        comment="Scope for auto-renewed tokens (full or certificates_only)"
    )
```

---

**Service Layer:**

```python
# app/services/token_service.py - –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥
from datetime import datetime, timedelta, timezone

class TokenService:

    AUTO_RENEWAL_THRESHOLD_HOURS = 24  # Renew when token < 24h remaining

    @staticmethod
    def check_and_renew_user_tokens(
        user_id: UUID,
        db: Session
    ) -> dict:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏.

        Logic:
            1. –ï—Å–ª–∏ auto_renew_enabled = False ‚Üí skip
            2. –ù–∞–π—Ç–∏ –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            3. –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–æ–∫–µ–Ω–∞ —Å expires_at < (now + 24h) ‚Üí —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π
            4. –ï—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–ª–∞–Ω—Å–∞ ‚Üí pause auto-renewal, send email

        Returns:
            {
                "renewed_count": int,
                "failed": bool,
                "failure_reason": str | None,
                "new_balance": float
            }
        """
        # Get user with lock
        user = db.query(User).filter(User.id == user_id).with_for_update().first()

        if not user or not user.auto_renew_enabled:
            return {"renewed_count": 0, "failed": False}

        # Check auto_renew_duration_hours configured
        if not user.auto_renew_duration_hours:
            return {"renewed_count": 0, "failed": True, "failure_reason": "Auto-renewal duration not configured"}

        # Find expiring tokens
        now = datetime.now(timezone.utc)
        threshold = now + timedelta(hours=TokenService.AUTO_RENEWAL_THRESHOLD_HOURS)

        expiring_tokens = db.query(AccessToken).filter(
            AccessToken.user_id == user.id,
            AccessToken.is_active == True,
            AccessToken.activated_at.isnot(None)  # Only activated tokens
        ).all()

        # Filter tokens that expire within 24h
        tokens_to_renew = [
            t for t in expiring_tokens
            if t.expires_at and t.expires_at <= threshold
        ]

        if not tokens_to_renew:
            return {"renewed_count": 0, "failed": False}

        # Calculate cost
        cost_per_token = TokenService.calculate_token_cost(
            duration_hours=user.auto_renew_duration_hours
        )
        total_cost = cost_per_token * len(tokens_to_renew)

        # Check balance
        if user.currency_balance < total_cost:
            # Pause auto-renewal
            user.auto_renew_enabled = False
            db.commit()

            # Send email notification (–±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –≤ Sprint 2)
            # EmailService.send_auto_renewal_failed(user, total_cost)

            return {
                "renewed_count": 0,
                "failed": True,
                "failure_reason": f"Insufficient balance. Required: {total_cost} ZNC, Available: {user.currency_balance} ZNC"
            }

        # Deduct balance
        user.currency_balance -= total_cost

        # Create new tokens
        renewed_count = 0
        for old_token in tokens_to_renew:
            new_token = TokenService.generate_access_token(
                user_id=user.id,
                duration_hours=user.auto_renew_duration_hours,
                scope=user.auto_renew_scope or "full",
                db=db
            )
            renewed_count += 1

        # Create transaction
        transaction = Transaction(
            user_id=user.id,
            amount=-total_cost,
            transaction_type=TransactionType.PURCHASE,
            description=f"Auto-renewal: {renewed_count} tokens x {user.auto_renew_duration_hours}h"
        )
        db.add(transaction)

        # Award referral bonus (if user was referred)
        CurrencyService.award_referral_bonus(
            user_id=user.id,
            purchase_amount=total_cost,
            db=db
        )

        db.commit()
        db.refresh(user)

        # Send email notification (–±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –≤ Sprint 2)
        # EmailService.send_auto_renewal_success(user, renewed_count, total_cost)

        return {
            "renewed_count": renewed_count,
            "failed": False,
            "new_balance": float(user.currency_balance)
        }
```

---

**Background Task (APScheduler):**

```python
# app/core/renewal_scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from app.services.token_service import TokenService
from app.core.database import get_db
from app.models.user import User
import logging

logger = logging.getLogger(__name__)

async def check_all_users_for_renewal():
    """
    Background task: –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å auto_renew_enabled.

    Scheduled: Daily at 00:00 UTC
    """
    db = next(get_db())

    try:
        # Find users with auto-renewal enabled
        users_to_check = db.query(User).filter(
            User.auto_renew_enabled == True,
            User.is_active == True
        ).all()

        logger.info(f"Checking {len(users_to_check)} users for auto-renewal")

        total_renewed = 0
        failed_count = 0

        for user in users_to_check:
            try:
                result = TokenService.check_and_renew_user_tokens(
                    user_id=user.id,
                    db=db
                )

                if result["renewed_count"] > 0:
                    total_renewed += result["renewed_count"]
                    logger.info(f"User {user.username}: Renewed {result['renewed_count']} tokens")

                if result["failed"]:
                    failed_count += 1
                    logger.warning(f"User {user.username}: Auto-renewal failed - {result.get('failure_reason')}")

            except Exception as e:
                logger.error(f"Error renewing tokens for user {user.username}: {str(e)}")
                failed_count += 1

        logger.info(f"Auto-renewal complete: {total_renewed} tokens renewed, {failed_count} failures")

    finally:
        db.close()

# Add to scheduler in app/main.py
def setup_renewal_scheduler(app: FastAPI):
    scheduler = AsyncIOScheduler()

    # Run daily at 00:00 UTC
    scheduler.add_job(
        check_all_users_for_renewal,
        trigger="cron",
        hour=0,
        minute=0,
        id="auto_renewal_check"
    )

    scheduler.start()

    @app.on_event("shutdown")
    async def shutdown_scheduler():
        scheduler.shutdown()
```

---

**API Endpoints:**

```python
# app/api/v1/users.py - –Ω–æ–≤—ã–µ endpoints
@router.put("/me/auto-renewal")
async def configure_auto_renewal(
    enabled: bool,
    duration_hours: int = None,
    scope: str = "full",
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–æ–≤.

    Body:
        {
            "enabled": true,
            "duration_hours": 24,  # Required if enabled=true
            "scope": "full"  # "full" or "certificates_only"
        }

    Validation:
        - duration_hours must be in [1, 12, 24, 168, 720]
        - scope must be "full" or "certificates_only"

    Returns:
        {
            "auto_renew_enabled": true,
            "auto_renew_duration_hours": 24,
            "auto_renew_scope": "full",
            "cost_per_renewal": 18.00
        }
    """
    # Validation
    if enabled and not duration_hours:
        raise HTTPException(status_code=400, detail="duration_hours required when enabling auto-renewal")

    if enabled and duration_hours not in [1, 12, 24, 168, 720]:
        raise HTTPException(status_code=400, detail="Invalid duration_hours. Must be 1, 12, 24, 168, or 720")

    if scope not in ["full", "certificates_only"]:
        raise HTTPException(status_code=400, detail="Invalid scope. Must be 'full' or 'certificates_only'")

    # Update user
    current_user.auto_renew_enabled = enabled
    current_user.auto_renew_duration_hours = duration_hours if enabled else None
    current_user.auto_renew_scope = scope if enabled else None

    db.commit()
    db.refresh(current_user)

    # Calculate cost
    cost_per_renewal = 0.0
    if enabled:
        cost_per_renewal = float(TokenService.calculate_token_cost(duration_hours))

    return {
        "auto_renew_enabled": current_user.auto_renew_enabled,
        "auto_renew_duration_hours": current_user.auto_renew_duration_hours,
        "auto_renew_scope": current_user.auto_renew_scope,
        "cost_per_renewal": cost_per_renewal
    }

@router.get("/me/auto-renewal")
async def get_auto_renewal_config(
    current_user: User = Depends(get_current_active_user)
):
    """
    –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏—è.
    """
    cost_per_renewal = 0.0
    if current_user.auto_renew_enabled:
        cost_per_renewal = float(TokenService.calculate_token_cost(
            current_user.auto_renew_duration_hours
        ))

    return {
        "auto_renew_enabled": current_user.auto_renew_enabled,
        "auto_renew_duration_hours": current_user.auto_renew_duration_hours,
        "auto_renew_scope": current_user.auto_renew_scope,
        "cost_per_renewal": cost_per_renewal
    }
```

---

**Database Migration:**

```python
# alembic/versions/xxx_add_auto_renewal.py
"""add auto renewal

Revision ID: xxx
Revises: yyy
Create Date: 2025-XX-XX

"""
from alembic import op
import sqlalchemy as sa

def upgrade():
    # Add auto-renewal fields to users table
    op.add_column('users', sa.Column('auto_renew_enabled', sa.Boolean, nullable=False, server_default='false'))
    op.add_column('users', sa.Column('auto_renew_duration_hours', sa.Integer, nullable=True))
    op.add_column('users', sa.Column('auto_renew_scope', sa.String(50), nullable=True, server_default='full'))

def downgrade():
    op.drop_column('users', 'auto_renew_scope')
    op.drop_column('users', 'auto_renew_duration_hours')
    op.drop_column('users', 'auto_renew_enabled')
```

---

**Testing Plan:**

```python
# tests/test_auto_renewal.py

def test_configure_auto_renewal(test_db, test_user):
    """–¢–µ—Å—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ auto-renewal"""
    # Enable auto-renewal
    test_user.auto_renew_enabled = True
    test_user.auto_renew_duration_hours = 24
    test_user.auto_renew_scope = "full"
    test_db.commit()

    assert test_user.auto_renew_enabled == True
    assert test_user.auto_renew_duration_hours == 24

def test_auto_renew_expiring_tokens(test_db, test_user):
    """–¢–µ—Å—Ç –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏—è –∏—Å—Ç–µ–∫–∞—é—â–∏—Ö —Ç–æ–∫–µ–Ω–æ–≤"""
    # Setup: user with auto-renewal –∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–º –±–∞–ª–∞–Ω—Å–æ–º
    test_user.auto_renew_enabled = True
    test_user.auto_renew_duration_hours = 24
    test_user.currency_balance = Decimal("100.00")
    test_db.commit()

    # Create expiring token (activated 23 hours ago)
    token = AccessToken(
        user_id=test_user.id,
        token=secrets.token_urlsafe(48),
        duration_hours=24,
        activated_at=datetime.now(timezone.utc) - timedelta(hours=23)
    )
    test_db.add(token)
    test_db.commit()

    # Run renewal check
    result = TokenService.check_and_renew_user_tokens(
        user_id=test_user.id,
        db=test_db
    )

    # Assertions
    assert result["renewed_count"] == 1
    assert result["failed"] == False
    test_db.refresh(test_user)
    assert test_user.currency_balance == Decimal("82.00")  # 100 - 18

def test_auto_renew_insufficient_balance(test_db, test_user):
    """–¢–µ—Å—Ç auto-renewal —Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–º –±–∞–ª–∞–Ω—Å–æ–º"""
    # Setup: user with low balance
    test_user.auto_renew_enabled = True
    test_user.auto_renew_duration_hours = 24
    test_user.currency_balance = Decimal("5.00")  # Not enough for 24h token (18 ZNC)
    test_db.commit()

    # Create expiring token
    token = AccessToken(
        user_id=test_user.id,
        token=secrets.token_urlsafe(48),
        duration_hours=24,
        activated_at=datetime.now(timezone.utc) - timedelta(hours=23)
    )
    test_db.add(token)
    test_db.commit()

    # Run renewal check
    result = TokenService.check_and_renew_user_tokens(
        user_id=test_user.id,
        db=test_db
    )

    # Assertions
    assert result["renewed_count"] == 0
    assert result["failed"] == True
    assert "Insufficient balance" in result["failure_reason"]

    # Auto-renewal should be disabled
    test_db.refresh(test_user)
    assert test_user.auto_renew_enabled == False

def test_auto_renew_multiple_tokens(test_db, test_user):
    """–¢–µ—Å—Ç auto-renewal –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ç–æ–∫–µ–Ω–æ–≤ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ"""
    test_user.auto_renew_enabled = True
    test_user.auto_renew_duration_hours = 24
    test_user.currency_balance = Decimal("200.00")
    test_db.commit()

    # Create 3 expiring tokens
    for i in range(3):
        token = AccessToken(
            user_id=test_user.id,
            token=secrets.token_urlsafe(48),
            duration_hours=24,
            activated_at=datetime.now(timezone.utc) - timedelta(hours=23)
        )
        test_db.add(token)
    test_db.commit()

    # Run renewal
    result = TokenService.check_and_renew_user_tokens(
        user_id=test_user.id,
        db=test_db
    )

    # Assertions
    assert result["renewed_count"] == 3
    test_db.refresh(test_user)
    assert test_user.currency_balance == Decimal("146.00")  # 200 - (18 * 3)
```

---

**Security Considerations:**

- ‚úÖ **Opt-in by default** - auto_renew_enabled = False
- ‚úÖ **Balance validation** –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º renewal
- ‚úÖ **Auto-pause** –ø—Ä–∏ insufficient balance (–Ω–µ –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏)
- ‚úÖ **Email notifications** –ø—Ä–∏ success/failure (Sprint 2)
- ‚úÖ **Row-level locking** –¥–ª—è balance updates
- ‚úÖ **Audit logging** –≤—Å–µ—Ö auto-renewal –æ–ø–µ—Ä–∞—Ü–∏–π

---

**User Experience Considerations:**

1. **Email reminders** (Sprint 2):
   - 3 –¥–Ω—è –¥–æ auto-renewal: "Your token will auto-renew in 3 days"
   - Immediately after renewal: "Your token was auto-renewed"
   - On failure: "Auto-renewal failed due to insufficient balance"

2. **Dashboard indicator**:
   - Show "Auto-Renewal Active" badge –≤ UI
   - Display next renewal date –∏ cost

3. **Easy disable**:
   - One-click toggle –≤ settings
   - No penalty for disabling

---

**Performance Impact:**

- **Daily background task**: <1 minute –¥–ª—è 10,000 users
- **Batch processing**: –ú–æ–∂–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å bulk inserts
- **Database load**: Low (runs once per day, off-peak hours)

---

## Token Gifting (–ü–æ–¥–∞—Ä–æ—á–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã)

### –ë–∏–∑–Ω–µ—Å-–æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ

**–ü—Ä–æ–±–ª–µ–º–∞:** –ù–µ—Ç –º–µ—Ö–∞–Ω–∏–∑–º–∞ –ø—Ä–∏–≤–ª–µ—á–µ–Ω–∏—è —á–µ—Ä–µ–∑ social sharing. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –º–æ–≥—É—Ç –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –æ–ø—ã—Ç–æ–º —Å –¥—Ä—É–∑—å—è–º–∏.

**–†–µ—à–µ–Ω–∏–µ:** –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–¥–∞—Ä–∏—Ç—å —Ç–æ–∫–µ–Ω –¥—Ä—É–≥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é (by email).

**–ú–µ—Ö–∞–Ω–∏–∫–∞:**
1. User A –ø–æ–∫—É–ø–∞–µ—Ç —Ç–æ–∫–µ–Ω
2. User A –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç gift –¥—Ä—É–≥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é (email)
3. Email notification —Å access token
4. Recipient –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç —Ç–æ–∫–µ–Ω

**–¶–µ–Ω–Ω–æ—Å—Ç—å:**
- **Viral growth**: Social sharing –º–µ—Ö–∞–Ω–∏–∑–º
- **Trial experience**: –ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –ø–æ–ª—É—á–∞—é—Ç free trial
- **Revenue**: Gifting —Ç—Ä–µ–±—É–µ—Ç –ø–æ–∫—É–ø–∫–∏ —Ç–æ–∫–µ–Ω–∞

**Expected Impact:**
- User acquisition: +10-20% —á–µ—Ä–µ–∑ gifted tokens
- Conversion: 30-40% gift recipients —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è paying users

---

### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏

**Database Model Changes:**

```python
# app/models/token.py - –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—è
class AccessToken(Base):
    # ... existing fields

    gifted_to_email = Column(
        String,
        nullable=True,
        comment="Email recipient (if gift)"
    )

    gifted_at = Column(
        DateTime(timezone=True),
        nullable=True,
        comment="Timestamp when token was gifted"
    )
```

---

**API Endpoints:**

```python
# app/api/v1/tokens.py - –Ω–æ–≤—ã–π endpoint
@router.post("/{token_id}/gift")
async def gift_token(
    token_id: UUID,
    recipient_email: str,
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    –ü–æ–¥–∞—Ä–∏—Ç—å —Ç–æ–∫–µ–Ω –¥—Ä—É–≥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø–æ email.

    Requirements:
        - Token must belong to current user
        - Token must not be activated yet
        - Token cannot be already gifted

    Body:
        {
            "recipient_email": "friend@example.com"
        }

    Returns:
        {
            "message": "Token gifted to friend@example.com",
            "token_id": "uuid",
            "recipient_email": "friend@example.com",
            "gifted_at": "ISO timestamp"
        }

    Errors:
        404: Token not found
        400: Token already activated/gifted
    """
    # Get token
    token = db.query(AccessToken).filter(
        AccessToken.id == token_id,
        AccessToken.user_id == current_user.id
    ).first()

    if not token:
        raise HTTPException(status_code=404, detail="Token not found")

    if token.activated_at:
        raise HTTPException(status_code=400, detail="Token already activated")

    if token.gifted_at:
        raise HTTPException(status_code=400, detail="Token already gifted")

    # Validate email format
    if not re.match(r"[^@]+@[^@]+\.[^@]+", recipient_email):
        raise HTTPException(status_code=400, detail="Invalid email format")

    # Mark as gifted
    token.gifted_to_email = recipient_email
    token.gifted_at = datetime.now(timezone.utc)

    db.commit()
    db.refresh(token)

    # Send email notification
    await EmailService.send_gift_token(
        sender=current_user,
        recipient_email=recipient_email,
        token=token
    )

    # Audit log
    audit_log = AuditLog(
        user_id=current_user.id,
        action="token_gifted",
        resource_type="access_token",
        resource_id=str(token.id),
        details={
            "recipient_email": recipient_email,
            "token_duration": token.duration_hours,
            "token_scope": token.scope
        }
    )
    db.add(audit_log)
    db.commit()

    return {
        "message": f"Token gifted to {recipient_email}",
        "token_id": str(token.id),
        "recipient_email": recipient_email,
        "gifted_at": token.gifted_at.isoformat()
    }
```

---

**Email Template:**

```python
# app/services/email_service.py
class EmailService:

    @staticmethod
    async def send_gift_token(sender: User, recipient_email: str, token: AccessToken):
        """
        Send email notification with gifted token.
        """
        message = MessageSchema(
            subject=f"{sender.username} sent you a Zenzefi access token!",
            recipients=[recipient_email],
            body=f"""
            Hello!

            {sender.username} ({sender.email}) has gifted you a Zenzefi access token:

            Token: {token.token}
            Duration: {token.duration_hours} hours
            Scope: {token.scope}

            To use this token:
            1. Download Zenzefi Desktop Client: {settings.FRONTEND_URL}/downloads
            2. Register an account (or login if you already have one)
            3. Activate this token in the client

            The token will expire {token.duration_hours} hours after activation.

            Enjoy your Zenzefi experience!

            Best regards,
            Zenzefi Team
            """,
            subtype="plain"
        )
        await FastMail(conf).send_message(message)
```

---

**Database Migration:**

```python
# alembic/versions/xxx_add_token_gifting.py
"""add token gifting

Revision ID: xxx
Revises: yyy
Create Date: 2025-XX-XX

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

def upgrade():
    # Add gifting fields to access_tokens table
    op.add_column('access_tokens', sa.Column('gifted_to_email', sa.String, nullable=True))
    op.add_column('access_tokens', sa.Column('gifted_at', sa.DateTime(timezone=True), nullable=True))

    # Create index for gifted tokens lookup
    op.create_index('ix_access_tokens_gifted_to_email', 'access_tokens', ['gifted_to_email'])

def downgrade():
    op.drop_index('ix_access_tokens_gifted_to_email', 'access_tokens')
    op.drop_column('access_tokens', 'gifted_at')
    op.drop_column('access_tokens', 'gifted_to_email')
```

---

**Testing Plan:**

```python
# tests/test_token_gifting.py

def test_gift_token_success(test_db, test_user, client):
    """–¢–µ—Å—Ç —É—Å–ø–µ—à–Ω–æ–≥–æ gifting —Ç–æ–∫–µ–Ω–∞"""
    # Create token
    token = AccessToken(
        user_id=test_user.id,
        token=secrets.token_urlsafe(48),
        duration_hours=24,
        scope="full"
    )
    test_db.add(token)
    test_db.commit()

    # Get JWT
    jwt_token = create_test_jwt_token(test_user)

    # Gift token
    response = client.post(
        f"/api/v1/tokens/{token.id}/gift",
        json={"recipient_email": "friend@example.com"},
        headers={"Authorization": f"Bearer {jwt_token}"}
    )

    assert response.status_code == 200
    data = response.json()
    assert data["recipient_email"] == "friend@example.com"
    assert "gifted_at" in data

    # Verify database
    test_db.refresh(token)
    assert token.gifted_to_email == "friend@example.com"
    assert token.gifted_at is not None

def test_gift_activated_token(test_db, test_user, client):
    """–¢–µ—Å—Ç: –Ω–µ–ª—å–∑—è –ø–æ–¥–∞—Ä–∏—Ç—å –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω"""
    # Create activated token
    token = AccessToken(
        user_id=test_user.id,
        token=secrets.token_urlsafe(48),
        duration_hours=24,
        activated_at=datetime.now(timezone.utc)
    )
    test_db.add(token)
    test_db.commit()

    jwt_token = create_test_jwt_token(test_user)

    # Try to gift
    response = client.post(
        f"/api/v1/tokens/{token.id}/gift",
        json={"recipient_email": "friend@example.com"},
        headers={"Authorization": f"Bearer {jwt_token}"}
    )

    assert response.status_code == 400
    assert "already activated" in response.json()["detail"]

def test_gift_already_gifted_token(test_db, test_user, client):
    """–¢–µ—Å—Ç: –Ω–µ–ª—å–∑—è –ø–æ–¥–∞—Ä–∏—Ç—å —É–∂–µ –ø–æ–¥–∞—Ä–µ–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω"""
    # Create gifted token
    token = AccessToken(
        user_id=test_user.id,
        token=secrets.token_urlsafe(48),
        duration_hours=24,
        gifted_to_email="first@example.com",
        gifted_at=datetime.now(timezone.utc)
    )
    test_db.add(token)
    test_db.commit()

    jwt_token = create_test_jwt_token(test_user)

    # Try to gift again
    response = client.post(
        f"/api/v1/tokens/{token.id}/gift",
        json={"recipient_email": "second@example.com"},
        headers={"Authorization": f"Bearer {jwt_token}"}
    )

    assert response.status_code == 400
    assert "already gifted" in response.json()["detail"]

def test_gift_someone_elses_token(test_db, test_user, other_user, client):
    """–¢–µ—Å—Ç: –Ω–µ–ª—å–∑—è –ø–æ–¥–∞—Ä–∏—Ç—å —á—É–∂–æ–π —Ç–æ–∫–µ–Ω"""
    # Create token belonging to other_user
    token = AccessToken(
        user_id=other_user.id,
        token=secrets.token_urlsafe(48),
        duration_hours=24
    )
    test_db.add(token)
    test_db.commit()

    jwt_token = create_test_jwt_token(test_user)

    # Try to gift
    response = client.post(
        f"/api/v1/tokens/{token.id}/gift",
        json={"recipient_email": "friend@example.com"},
        headers={"Authorization": f"Bearer {jwt_token}"}
    )

    assert response.status_code == 404
```

---

**Security Considerations:**

- ‚úÖ **Ownership validation** - —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç –ø–æ–¥–∞—Ä–∏—Ç—å —Ç–æ–∫–µ–Ω
- ‚úÖ **State validation** - –Ω–µ–ª—å–∑—è –ø–æ–¥–∞—Ä–∏—Ç—å –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∏–ª–∏ —É–∂–µ –ø–æ–¥–∞—Ä–µ–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω
- ‚úÖ **Email validation** - –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ email
- ‚úÖ **Audit logging** - –≤—Å–µ gifting –æ–ø–µ—Ä–∞—Ü–∏–∏ –ª–æ–≥–∏—Ä—É—é—Ç—Å—è
- ‚úÖ **No duplicate gifts** - –æ–¥–∏–Ω —Ç–æ–∫–µ–Ω –º–æ–∂–Ω–æ –ø–æ–¥–∞—Ä–∏—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
- ‚úÖ **Email verification** - –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: verify recipient email before accepting gift

---

**Anti-Abuse Measures:**

1. **Rate limiting**: Max 10 gifts per day per user
2. **Minimum balance requirement**: User must have >50 ZNC to gift
3. **Token value limit**: Cannot gift tokens >24 hours duration without admin approval
4. **Audit monitoring**: Admin dashboard –¥–ª—è tracking suspicious gifting patterns

---

## Sprint 3: Developer Ecosystem (v0.9.0-beta)

**–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:** 8-10 –¥–Ω–µ–π
**–¶–µ–ª—å:** –†–∞—Å—à–∏—Ä–∏—Ç—å –ø–ª–∞—Ç—Ñ–æ—Ä–º—É –¥–ª—è enterprise/developer use cases
**Expected ROI:** +30-50% B2B revenue growth

**–§–∏—á–∏:**
- Webhook Notifications (Webhook –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)
- Multi-Currency Support (–ú—É–ª—å—Ç–∏–≤–∞–ª—é—Ç–Ω–æ—Å—Ç—å)
- API Rate Limiting Tiers (–¢–∞—Ä–∏—Ñ–Ω—ã–µ –ø–ª–∞–Ω—ã)

**–°—Ç–∞—Ç—É—Å:** üìã –û—Ç–ª–æ–∂–µ–Ω–æ - –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –Ω–∞ B2C monetization

---

### Webhook Notifications (Webhook –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)

#### –ë–∏–∑–Ω–µ—Å-–æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ

**–ü—Ä–æ–±–ª–µ–º–∞:** B2B –∫–ª–∏–µ–Ω—Ç—ã —Ö–æ—Ç—è—Ç –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å Zenzefi –≤ —Å–≤–æ–∏ —Å–∏—Å—Ç–µ–º—ã. –ù–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–æ–±—ã—Ç–∏—è–º –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã.

**–†–µ—à–µ–Ω–∏–µ:** Webhook notifications –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–æ–±—ã—Ç–∏–π (token purchased, balance charged, session started).

**–¶–µ–Ω–Ω–æ—Å—Ç—å:**
- **B2B integration**: –ü–æ–∑–≤–æ–ª—è–µ—Ç –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ã–º –∫–ª–∏–µ–Ω—Ç–∞–º –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞—Ç—å workflows
- **Real-time updates**: Instant notifications –≤–º–µ—Å—Ç–æ polling API
- **Developer-friendly**: Standard webhook format (JSON POST)

**Expected Impact:**
- B2B revenue: +30-50% (enterprise customers pay premium for webhooks)
- API usage: -40-60% (webhooks –≤–º–µ—Å—Ç–æ polling)

---

#### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏

**Database Model:**

```python
# app/models/webhook.py
class WebhookEndpoint(Base):
    """
    User-defined webhook endpoint –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è event notifications.
    """
    __tablename__ = "webhook_endpoints"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)

    # Webhook configuration
    url = Column(String(500), nullable=False, comment="HTTPS URL –¥–ª—è webhook delivery")
    secret = Column(String(64), nullable=False, comment="HMAC secret –¥–ª—è signature verification")

    # Event subscriptions (JSON array)
    events = Column(JSONB, nullable=False, comment="List of subscribed events")

    # Status
    is_active = Column(Boolean, default=True, nullable=False)
    failed_deliveries = Column(Integer, default=0, nullable=False)
    last_delivery_at = Column(DateTime(timezone=True), nullable=True)

    # Metadata
    created_at = Column(DateTime(timezone=True), default=datetime.now(timezone.utc), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=datetime.now(timezone.utc))

    # Relationships
    user = relationship("User", backref="webhooks")


class WebhookDelivery(Base):
    """
    Log of webhook delivery attempts (for debugging and retry).
    """
    __tablename__ = "webhook_deliveries"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    webhook_id = Column(UUID(as_uuid=True), ForeignKey("webhook_endpoints.id", ondelete="CASCADE"), nullable=False)

    # Event details
    event_type = Column(String(50), nullable=False, comment="Event type (e.g., 'token.purchased')")
    payload = Column(JSONB, nullable=False, comment="Event payload (JSON)")

    # Delivery status
    status = Column(String(20), nullable=False, comment="pending, success, failed")
    response_code = Column(Integer, nullable=True)
    response_body = Column(Text, nullable=True)
    error_message = Column(Text, nullable=True)

    # Timing
    created_at = Column(DateTime(timezone=True), default=datetime.now(timezone.utc), nullable=False)
    delivered_at = Column(DateTime(timezone=True), nullable=True)

    # Relationships
    webhook = relationship("WebhookEndpoint", backref="deliveries")
```

---

**Service Layer:**

```python
# app/services/webhook_service.py
import hmac
import hashlib
import httpx
from typing import Dict, Any

class WebhookService:

    EVENT_TYPES = [
        "token.purchased",
        "token.activated",
        "token.revoked",
        "balance.charged",
        "balance.topped_up",
        "session.started",
        "session.ended"
    ]

    @staticmethod
    async def trigger_event(
        user_id: UUID,
        event_type: str,
        payload: Dict[Any, Any],
        db: Session
    ):
        """
        Trigger webhook event for user's subscribed endpoints.

        Args:
            user_id: User who triggered the event
            event_type: Event type (e.g., "token.purchased")
            payload: Event data
            db: Database session
        """
        # Find user's active webhooks subscribed to this event
        webhooks = db.query(WebhookEndpoint).filter(
            WebhookEndpoint.user_id == user_id,
            WebhookEndpoint.is_active == True,
            WebhookEndpoint.events.contains([event_type])  # PostgreSQL JSONB contains
        ).all()

        for webhook in webhooks:
            # Create delivery record
            delivery = WebhookDelivery(
                webhook_id=webhook.id,
                event_type=event_type,
                payload=payload,
                status="pending"
            )
            db.add(delivery)
            db.commit()
            db.refresh(delivery)

            # Deliver asynchronously
            await WebhookService.deliver_webhook(webhook, delivery, payload, db)

    @staticmethod
    async def deliver_webhook(
        webhook: WebhookEndpoint,
        delivery: WebhookDelivery,
        payload: Dict[Any, Any],
        db: Session
    ):
        """
        Deliver webhook to endpoint with HMAC signature.
        """
        # Generate HMAC signature
        signature = WebhookService.generate_signature(
            secret=webhook.secret,
            payload=payload
        )

        # Prepare request
        headers = {
            "Content-Type": "application/json",
            "X-Zenzefi-Signature": signature,
            "X-Zenzefi-Event": delivery.event_type,
            "X-Zenzefi-Delivery-ID": str(delivery.id)
        }

        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.post(
                    webhook.url,
                    json=payload,
                    headers=headers
                )

            # Update delivery record
            delivery.status = "success" if response.status_code == 200 else "failed"
            delivery.response_code = response.status_code
            delivery.response_body = response.text[:1000]  # Truncate
            delivery.delivered_at = datetime.now(timezone.utc)

            # Update webhook stats
            webhook.last_delivery_at = datetime.now(timezone.utc)
            if response.status_code != 200:
                webhook.failed_deliveries += 1

                # Disable webhook after 10 consecutive failures
                if webhook.failed_deliveries >= 10:
                    webhook.is_active = False

        except Exception as e:
            delivery.status = "failed"
            delivery.error_message = str(e)
            webhook.failed_deliveries += 1

        db.commit()

    @staticmethod
    def generate_signature(secret: str, payload: Dict[Any, Any]) -> str:
        """
        Generate HMAC-SHA256 signature for webhook payload.
        """
        payload_bytes = json.dumps(payload, sort_keys=True).encode('utf-8')
        signature = hmac.new(
            secret.encode('utf-8'),
            payload_bytes,
            hashlib.sha256
        ).hexdigest()
        return signature

    @staticmethod
    def verify_signature(secret: str, payload: Dict[Any, Any], signature: str) -> bool:
        """
        Verify HMAC signature from webhook request.
        """
        expected_signature = WebhookService.generate_signature(secret, payload)
        return hmac.compare_digest(expected_signature, signature)
```

---

**API Endpoints:**

```python
# app/api/v1/webhooks.py
@router.post("/")
async def create_webhook(
    url: str,
    events: List[str],
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Create webhook endpoint.

    Body:
        {
            "url": "https://example.com/webhooks/zenzefi",
            "events": ["token.purchased", "balance.charged"]
        }

    Returns:
        {
            "id": "uuid",
            "url": "https://...",
            "secret": "generated_secret",  # SAVE THIS - shown only once
            "events": ["token.purchased", "balance.charged"],
            "is_active": true
        }
    """
    # Validate URL (must be HTTPS)
    if not url.startswith("https://"):
        raise HTTPException(status_code=400, detail="Webhook URL must use HTTPS")

    # Validate events
    invalid_events = [e for e in events if e not in WebhookService.EVENT_TYPES]
    if invalid_events:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid events: {invalid_events}. Valid: {WebhookService.EVENT_TYPES}"
        )

    # Generate secret
    secret = secrets.token_urlsafe(48)

    # Create webhook
    webhook = WebhookEndpoint(
        user_id=current_user.id,
        url=url,
        secret=secret,
        events=events
    )
    db.add(webhook)
    db.commit()
    db.refresh(webhook)

    return {
        "id": str(webhook.id),
        "url": webhook.url,
        "secret": secret,  # IMPORTANT: Show only on creation
        "events": webhook.events,
        "is_active": webhook.is_active,
        "created_at": webhook.created_at.isoformat()
    }

@router.get("/")
async def list_webhooks(
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    List user's webhooks (secret –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è).
    """
    webhooks = db.query(WebhookEndpoint).filter(
        WebhookEndpoint.user_id == current_user.id
    ).all()

    return {
        "items": [
            {
                "id": str(w.id),
                "url": w.url,
                "events": w.events,
                "is_active": w.is_active,
                "failed_deliveries": w.failed_deliveries,
                "last_delivery_at": w.last_delivery_at.isoformat() if w.last_delivery_at else None,
                "created_at": w.created_at.isoformat()
            }
            for w in webhooks
        ]
    }

@router.delete("/{webhook_id}")
async def delete_webhook(
    webhook_id: UUID,
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Delete webhook endpoint.
    """
    webhook = db.query(WebhookEndpoint).filter(
        WebhookEndpoint.id == webhook_id,
        WebhookEndpoint.user_id == current_user.id
    ).first()

    if not webhook:
        raise HTTPException(status_code=404, detail="Webhook not found")

    db.delete(webhook)
    db.commit()

    return {"message": "Webhook deleted"}

@router.get("/{webhook_id}/deliveries")
async def get_webhook_deliveries(
    webhook_id: UUID,
    limit: int = 50,
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """
    Get webhook delivery history (for debugging).
    """
    webhook = db.query(WebhookEndpoint).filter(
        WebhookEndpoint.id == webhook_id,
        WebhookEndpoint.user_id == current_user.id
    ).first()

    if not webhook:
        raise HTTPException(status_code=404, detail="Webhook not found")

    deliveries = db.query(WebhookDelivery).filter(
        WebhookDelivery.webhook_id == webhook_id
    ).order_by(WebhookDelivery.created_at.desc()).limit(limit).all()

    return {
        "items": [
            {
                "id": str(d.id),
                "event_type": d.event_type,
                "status": d.status,
                "response_code": d.response_code,
                "error_message": d.error_message,
                "created_at": d.created_at.isoformat(),
                "delivered_at": d.delivered_at.isoformat() if d.delivered_at else None
            }
            for d in deliveries
        ]
    }
```

---

**Integration Example:**

```python
# app/services/token_service.py - –¥–æ–±–∞–≤–∏—Ç—å webhook trigger
async def purchase_token(user_id: UUID, duration_hours: int, db: Session):
    # ... existing token purchase logic

    # Trigger webhook event
    await WebhookService.trigger_event(
        user_id=user.id,
        event_type="token.purchased",
        payload={
            "token_id": str(token.id),
            "duration_hours": duration_hours,
            "cost_znc": float(cost),
            "balance_remaining": float(user.currency_balance),
            "timestamp": datetime.now(timezone.utc).isoformat()
        },
        db=db
    )
```

---

### Multi-Currency Support (–ú—É–ª—å—Ç–∏–≤–∞–ª—é—Ç–Ω–æ—Å—Ç—å)

#### –ë–∏–∑–Ω–µ—Å-–æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ

**–ü—Ä–æ–±–ª–µ–º–∞:** ZNC (internal currency) —É–¥–æ–±–Ω–∞, –Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∏–∑ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω —Ö–æ—Ç—è—Ç –≤–∏–¥–µ—Ç—å —Ü–µ–Ω—ã –≤ —Å–≤–æ–µ–π –≤–∞–ª—é—Ç–µ (USD, EUR, RUB).

**–†–µ—à–µ–Ω–∏–µ:** –ü–æ–¥–¥–µ—Ä–∂–∫–∞ multiple currencies —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–µ–π –ø—Ä–∏ top-up.

**Expected Impact:**
- Conversion rate: +15-25% (–ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ —Ü–µ–Ω—ã)
- Global expansion: Easier market entry

---

### API Rate Limiting Tiers (–¢–∞—Ä–∏—Ñ–Ω—ã–µ –ø–ª–∞–Ω—ã)

#### –ë–∏–∑–Ω–µ—Å-–æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ

**–ü—Ä–æ–±–ª–µ–º–∞:** –í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –ª–∏–º–∏—Ç—ã (100 req/min). Enterprise –∫–ª–∏–µ–Ω—Ç—ã –Ω—É–∂–¥–∞—é—Ç—Å—è –≤ higher limits.

**–†–µ—à–µ–Ω–∏–µ:** Tier-based rate limiting (Free, Pro, Enterprise).

**Tiers:**
- Free: 100 req/min
- Pro: 500 req/min (+10 ZNC/month)
- Enterprise: 2000 req/min (+50 ZNC/month)

**Expected Impact:**
- B2B revenue: +40-60% (subscription fees)
- Premium users: 10-15% upgrade rate

---

## Roadmap –¥–ª—è Postponed Features

**Short-term (After v0.8.0):**
- ‚úÖ Stabilize Email Notifications (Sprint 2)
- ‚úÖ Monitor user engagement metrics

**Mid-term (v0.9.0-v1.0.0):**
- ‚è∏Ô∏è Token Auto-Renewal (–ø–æ—Å–ª–µ Email Notifications)
- ‚è∏Ô∏è Token Gifting (–ø–æ—Å–ª–µ —Ä–æ—Å—Ç–∞ user base >500 –∞–∫—Ç–∏–≤–Ω—ã—Ö)

**Long-term (v1.1.0+):**
- ‚è∏Ô∏è Sprint 3 —Ñ–∏—á–∏ (B2B/Enterprise focus)
- ‚è∏Ô∏è Webhook Notifications
- ‚è∏Ô∏è Multi-Currency Support
- ‚è∏Ô∏è API Rate Limiting Tiers

**Success Metrics –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏:**
- Token Auto-Renewal: Email delivery rate >95%, bounce rate <5%
- Token Gifting: MAU >500, retention rate >40%
- Sprint 3: B2B leads >10, enterprise inquiries >3

---

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–≠—Ç–∏ —Ñ–∏—á–∏ **–æ—Ç–ª–æ–∂–µ–Ω—ã, –Ω–æ –Ω–µ –æ—Ç–º–µ–Ω–µ–Ω—ã**. –û–Ω–∏ –±—É–¥—É—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –ø–æ—Å–ª–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Å–ª–µ–¥—É—é—â–∏—Ö milestones:

1. **Phase 5-6 (v0.7.0-v0.8.0)** —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã –≤ production
2. **User base** –≤—ã—Ä–æ—Å –¥–æ 500+ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
3. **Email infrastructure** —Å—Ç–∞–±–∏–ª—å–Ω–∞ –∏ –Ω–∞–¥–µ–∂–Ω–∞
4. **B2B demand** –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω (>10 enterprise inquiries)

**Next Steps:**
- –§–æ–∫—É—Å –Ω–∞ Token Bundles + Referral System (Sprint 1)
- –†–µ–∞–ª–∏–∑–∞—Ü–∏—è Usage Analytics + Email Notifications (Sprint 2)
- –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –º–µ—Ç—Ä–∏–∫ –¥–ª—è –æ—Ü–µ–Ω–∫–∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫ postponed features

**–°–º. —Ç–∞–∫–∂–µ:**
- [ROADMAP_V1.md](./ROADMAP_V1.md) - –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π roadmap –±–µ–∑ postponed features
- [PHASE_FUTURE_DETAILED.md](./PHASE_FUTURE_DETAILED.md) - –ê–∫—Ç–∏–≤–Ω—ã–π –ø–ª–∞–Ω —Ä–∞–∑–≤–∏—Ç–∏—è (v0.7.0-v0.8.0)
